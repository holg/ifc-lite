// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(ifc_lite_ffiFFI)
import ifc_lite_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_ifc_lite_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_ifc_lite_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}




/**
 * Main IFC Scene interface - thread-safe
 */
public protocol IfcSceneProtocol : AnyObject {
    
    func addToSelection(entityId: UInt64) 
    
    /**
     * Clear all scene data
     */
    func clear() 
    
    func clearSelection() 
    
    /**
     * Get scene bounds
     */
    func getBounds()  -> SceneBounds?
    
    func getCameraState()  -> CameraState
    
    /**
     * Get all entities
     */
    func getEntities()  -> [EntityInfo]
    
    /**
     * Get entity by ID
     */
    func getEntity(id: UInt64)  -> EntityInfo?
    
    /**
     * Get mesh for specific entity
     */
    func getMesh(entityId: UInt64)  -> MeshData?
    
    /**
     * Get all meshes
     */
    func getMeshes()  -> [MeshData]
    
    /**
     * Get properties for entity
     */
    func getProperties(entityId: UInt64)  -> [PropertySet]
    
    func getSectionPlane()  -> SectionPlane
    
    func getSelection()  -> SelectionState
    
    /**
     * Get spatial hierarchy tree
     */
    func getSpatialTree()  -> SpatialNode?
    
    func getVisibility()  -> VisibilityState
    
    func getVisibleCount()  -> UInt32
    
    func hideEntity(entityId: UInt64) 
    
    func isEntityVisible(entityId: UInt64)  -> Bool
    
    /**
     * Check if scene has data
     */
    func isLoaded()  -> Bool
    
    func isolateEntities(entityIds: [UInt64]) 
    
    func isolateEntity(entityId: UInt64) 
    
    /**
     * Load IFC from bytes
     */
    func loadBytes(data: Data) throws  -> LoadResult
    
    /**
     * Load IFC from file path (native only)
     */
    func loadFile(path: String) throws  -> LoadResult
    
    /**
     * Load IFC from string content
     */
    func loadString(content: String) throws  -> LoadResult
    
    func removeFromSelection(entityId: UInt64) 
    
    func select(entityId: UInt64) 
    
    func setCameraState(state: CameraState) 
    
    func setSectionPlane(plane: SectionPlane) 
    
    func setStoreyFilter(storey: String?) 
    
    func showAll() 
    
    func showEntity(entityId: UInt64) 
    
    func toggleSelection(entityId: UInt64) 
    
}

/**
 * Main IFC Scene interface - thread-safe
 */
open class IfcScene:
    IfcSceneProtocol {
    fileprivate let pointer: UnsafeMutableRawPointer!

    /// Used to instantiate a [FFIObject] without an actual pointer, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoPointer {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
    required public init(unsafeFromRawPointer pointer: UnsafeMutableRawPointer) {
        self.pointer = pointer
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noPointer: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing [Pointer] the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noPointer: NoPointer) {
        self.pointer = nil
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiClonePointer() -> UnsafeMutableRawPointer {
        return try! rustCall { uniffi_ifc_lite_ffi_fn_clone_ifcscene(self.pointer, $0) }
    }
    /**
     * Create a new empty scene
     */
public convenience init() {
    let pointer =
        try! rustCall() {
    uniffi_ifc_lite_ffi_fn_constructor_ifcscene_new($0
    )
}
    self.init(unsafeFromRawPointer: pointer)
}

    deinit {
        guard let pointer = pointer else {
            return
        }

        try! rustCall { uniffi_ifc_lite_ffi_fn_free_ifcscene(pointer, $0) }
    }

    

    
open func addToSelection(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_add_to_selection(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
    /**
     * Clear all scene data
     */
open func clear() {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_clear(self.uniffiClonePointer(),$0
    )
}
}
    
open func clearSelection() {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_clear_selection(self.uniffiClonePointer(),$0
    )
}
}
    
    /**
     * Get scene bounds
     */
open func getBounds() -> SceneBounds? {
    return try!  FfiConverterOptionTypeSceneBounds.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_bounds(self.uniffiClonePointer(),$0
    )
})
}
    
open func getCameraState() -> CameraState {
    return try!  FfiConverterTypeCameraState.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_camera_state(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get all entities
     */
open func getEntities() -> [EntityInfo] {
    return try!  FfiConverterSequenceTypeEntityInfo.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_entities(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get entity by ID
     */
open func getEntity(id: UInt64) -> EntityInfo? {
    return try!  FfiConverterOptionTypeEntityInfo.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_entity(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(id),$0
    )
})
}
    
    /**
     * Get mesh for specific entity
     */
open func getMesh(entityId: UInt64) -> MeshData? {
    return try!  FfiConverterOptionTypeMeshData.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_mesh(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
})
}
    
    /**
     * Get all meshes
     */
open func getMeshes() -> [MeshData] {
    return try!  FfiConverterSequenceTypeMeshData.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_meshes(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get properties for entity
     */
open func getProperties(entityId: UInt64) -> [PropertySet] {
    return try!  FfiConverterSequenceTypePropertySet.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_properties(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
})
}
    
open func getSectionPlane() -> SectionPlane {
    return try!  FfiConverterTypeSectionPlane.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_section_plane(self.uniffiClonePointer(),$0
    )
})
}
    
open func getSelection() -> SelectionState {
    return try!  FfiConverterTypeSelectionState.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_selection(self.uniffiClonePointer(),$0
    )
})
}
    
    /**
     * Get spatial hierarchy tree
     */
open func getSpatialTree() -> SpatialNode? {
    return try!  FfiConverterOptionTypeSpatialNode.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_spatial_tree(self.uniffiClonePointer(),$0
    )
})
}
    
open func getVisibility() -> VisibilityState {
    return try!  FfiConverterTypeVisibilityState.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_visibility(self.uniffiClonePointer(),$0
    )
})
}
    
open func getVisibleCount() -> UInt32 {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_get_visible_count(self.uniffiClonePointer(),$0
    )
})
}
    
open func hideEntity(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_hide_entity(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
open func isEntityVisible(entityId: UInt64) -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_is_entity_visible(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
})
}
    
    /**
     * Check if scene has data
     */
open func isLoaded() -> Bool {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_is_loaded(self.uniffiClonePointer(),$0
    )
})
}
    
open func isolateEntities(entityIds: [UInt64]) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_isolate_entities(self.uniffiClonePointer(),
        FfiConverterSequenceUInt64.lower(entityIds),$0
    )
}
}
    
open func isolateEntity(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_isolate_entity(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
    /**
     * Load IFC from bytes
     */
open func loadBytes(data: Data)throws  -> LoadResult {
    return try  FfiConverterTypeLoadResult.lift(try rustCallWithError(FfiConverterTypeIfcError.lift) {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_load_bytes(self.uniffiClonePointer(),
        FfiConverterData.lower(data),$0
    )
})
}
    
    /**
     * Load IFC from file path (native only)
     */
open func loadFile(path: String)throws  -> LoadResult {
    return try  FfiConverterTypeLoadResult.lift(try rustCallWithError(FfiConverterTypeIfcError.lift) {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_load_file(self.uniffiClonePointer(),
        FfiConverterString.lower(path),$0
    )
})
}
    
    /**
     * Load IFC from string content
     */
open func loadString(content: String)throws  -> LoadResult {
    return try  FfiConverterTypeLoadResult.lift(try rustCallWithError(FfiConverterTypeIfcError.lift) {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_load_string(self.uniffiClonePointer(),
        FfiConverterString.lower(content),$0
    )
})
}
    
open func removeFromSelection(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_remove_from_selection(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
open func select(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_select(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
open func setCameraState(state: CameraState) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_set_camera_state(self.uniffiClonePointer(),
        FfiConverterTypeCameraState.lower(state),$0
    )
}
}
    
open func setSectionPlane(plane: SectionPlane) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_set_section_plane(self.uniffiClonePointer(),
        FfiConverterTypeSectionPlane.lower(plane),$0
    )
}
}
    
open func setStoreyFilter(storey: String?) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_set_storey_filter(self.uniffiClonePointer(),
        FfiConverterOptionString.lower(storey),$0
    )
}
}
    
open func showAll() {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_show_all(self.uniffiClonePointer(),$0
    )
}
}
    
open func showEntity(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_show_entity(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    
open func toggleSelection(entityId: UInt64) {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_method_ifcscene_toggle_selection(self.uniffiClonePointer(),
        FfiConverterUInt64.lower(entityId),$0
    )
}
}
    

}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIfcScene: FfiConverter {

    typealias FfiType = UnsafeMutableRawPointer
    typealias SwiftType = IfcScene

    public static func lift(_ pointer: UnsafeMutableRawPointer) throws -> IfcScene {
        return IfcScene(unsafeFromRawPointer: pointer)
    }

    public static func lower(_ value: IfcScene) -> UnsafeMutableRawPointer {
        return value.uniffiClonePointer()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IfcScene {
        let v: UInt64 = try readInt(&buf)
        // The Rust code won't compile if a pointer won't fit in a UInt64.
        // We have to go via `UInt` because that's the thing that's the size of a pointer.
        let ptr = UnsafeMutableRawPointer(bitPattern: UInt(truncatingIfNeeded: v))
        if (ptr == nil) {
            throw UniffiInternalError.unexpectedNullPointer
        }
        return try lift(ptr!)
    }

    public static func write(_ value: IfcScene, into buf: inout [UInt8]) {
        // This fiddling is because `Int` is the thing that's the same size as a pointer.
        // The Rust code won't compile if a pointer won't fit in a `UInt64`.
        writeInt(&buf, UInt64(bitPattern: Int64(Int(bitPattern: lower(value)))))
    }
}




#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIfcScene_lift(_ pointer: UnsafeMutableRawPointer) throws -> IfcScene {
    return try FfiConverterTypeIfcScene.lift(pointer)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIfcScene_lower(_ value: IfcScene) -> UnsafeMutableRawPointer {
    return FfiConverterTypeIfcScene.lower(value)
}


/**
 * Camera state
 */
public struct CameraState {
    public var azimuth: Float
    public var elevation: Float
    public var distance: Float
    public var targetX: Float
    public var targetY: Float
    public var targetZ: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(azimuth: Float, elevation: Float, distance: Float, targetX: Float, targetY: Float, targetZ: Float) {
        self.azimuth = azimuth
        self.elevation = elevation
        self.distance = distance
        self.targetX = targetX
        self.targetY = targetY
        self.targetZ = targetZ
    }
}



extension CameraState: Equatable, Hashable {
    public static func ==(lhs: CameraState, rhs: CameraState) -> Bool {
        if lhs.azimuth != rhs.azimuth {
            return false
        }
        if lhs.elevation != rhs.elevation {
            return false
        }
        if lhs.distance != rhs.distance {
            return false
        }
        if lhs.targetX != rhs.targetX {
            return false
        }
        if lhs.targetY != rhs.targetY {
            return false
        }
        if lhs.targetZ != rhs.targetZ {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(azimuth)
        hasher.combine(elevation)
        hasher.combine(distance)
        hasher.combine(targetX)
        hasher.combine(targetY)
        hasher.combine(targetZ)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCameraState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CameraState {
        return
            try CameraState(
                azimuth: FfiConverterFloat.read(from: &buf), 
                elevation: FfiConverterFloat.read(from: &buf), 
                distance: FfiConverterFloat.read(from: &buf), 
                targetX: FfiConverterFloat.read(from: &buf), 
                targetY: FfiConverterFloat.read(from: &buf), 
                targetZ: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: CameraState, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.azimuth, into: &buf)
        FfiConverterFloat.write(value.elevation, into: &buf)
        FfiConverterFloat.write(value.distance, into: &buf)
        FfiConverterFloat.write(value.targetX, into: &buf)
        FfiConverterFloat.write(value.targetY, into: &buf)
        FfiConverterFloat.write(value.targetZ, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCameraState_lift(_ buf: RustBuffer) throws -> CameraState {
    return try FfiConverterTypeCameraState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCameraState_lower(_ value: CameraState) -> RustBuffer {
    return FfiConverterTypeCameraState.lower(value)
}


/**
 * Entity information
 */
public struct EntityInfo {
    public var id: UInt64
    public var entityType: String
    public var name: String?
    public var globalId: String?
    public var storey: String?
    public var storeyElevation: Float?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, entityType: String, name: String?, globalId: String?, storey: String?, storeyElevation: Float?) {
        self.id = id
        self.entityType = entityType
        self.name = name
        self.globalId = globalId
        self.storey = storey
        self.storeyElevation = storeyElevation
    }
}



extension EntityInfo: Equatable, Hashable {
    public static func ==(lhs: EntityInfo, rhs: EntityInfo) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.entityType != rhs.entityType {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.globalId != rhs.globalId {
            return false
        }
        if lhs.storey != rhs.storey {
            return false
        }
        if lhs.storeyElevation != rhs.storeyElevation {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(entityType)
        hasher.combine(name)
        hasher.combine(globalId)
        hasher.combine(storey)
        hasher.combine(storeyElevation)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEntityInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EntityInfo {
        return
            try EntityInfo(
                id: FfiConverterUInt64.read(from: &buf), 
                entityType: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                globalId: FfiConverterOptionString.read(from: &buf), 
                storey: FfiConverterOptionString.read(from: &buf), 
                storeyElevation: FfiConverterOptionFloat.read(from: &buf)
        )
    }

    public static func write(_ value: EntityInfo, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterString.write(value.entityType, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.globalId, into: &buf)
        FfiConverterOptionString.write(value.storey, into: &buf)
        FfiConverterOptionFloat.write(value.storeyElevation, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityInfo_lift(_ buf: RustBuffer) throws -> EntityInfo {
    return try FfiConverterTypeEntityInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEntityInfo_lower(_ value: EntityInfo) -> RustBuffer {
    return FfiConverterTypeEntityInfo.lower(value)
}


/**
 * Load result
 */
public struct LoadResult {
    public var meshes: [MeshData]
    public var entities: [EntityInfo]
    public var spatialTree: SpatialNode?
    public var bounds: SceneBounds?
    public var loadTimeMs: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(meshes: [MeshData], entities: [EntityInfo], spatialTree: SpatialNode?, bounds: SceneBounds?, loadTimeMs: UInt64) {
        self.meshes = meshes
        self.entities = entities
        self.spatialTree = spatialTree
        self.bounds = bounds
        self.loadTimeMs = loadTimeMs
    }
}



extension LoadResult: Equatable, Hashable {
    public static func ==(lhs: LoadResult, rhs: LoadResult) -> Bool {
        if lhs.meshes != rhs.meshes {
            return false
        }
        if lhs.entities != rhs.entities {
            return false
        }
        if lhs.spatialTree != rhs.spatialTree {
            return false
        }
        if lhs.bounds != rhs.bounds {
            return false
        }
        if lhs.loadTimeMs != rhs.loadTimeMs {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(meshes)
        hasher.combine(entities)
        hasher.combine(spatialTree)
        hasher.combine(bounds)
        hasher.combine(loadTimeMs)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLoadResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoadResult {
        return
            try LoadResult(
                meshes: FfiConverterSequenceTypeMeshData.read(from: &buf), 
                entities: FfiConverterSequenceTypeEntityInfo.read(from: &buf), 
                spatialTree: FfiConverterOptionTypeSpatialNode.read(from: &buf), 
                bounds: FfiConverterOptionTypeSceneBounds.read(from: &buf), 
                loadTimeMs: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LoadResult, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeMeshData.write(value.meshes, into: &buf)
        FfiConverterSequenceTypeEntityInfo.write(value.entities, into: &buf)
        FfiConverterOptionTypeSpatialNode.write(value.spatialTree, into: &buf)
        FfiConverterOptionTypeSceneBounds.write(value.bounds, into: &buf)
        FfiConverterUInt64.write(value.loadTimeMs, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadResult_lift(_ buf: RustBuffer) throws -> LoadResult {
    return try FfiConverterTypeLoadResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoadResult_lower(_ value: LoadResult) -> RustBuffer {
    return FfiConverterTypeLoadResult.lower(value)
}


/**
 * Mesh data for rendering
 */
public struct MeshData {
    public var entityId: UInt64
    public var entityType: String
    public var name: String?
    public var positions: [Float]
    public var normals: [Float]
    public var indices: [UInt32]
    public var color: [Float]
    public var transform: [Float]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(entityId: UInt64, entityType: String, name: String?, positions: [Float], normals: [Float], indices: [UInt32], color: [Float], transform: [Float]) {
        self.entityId = entityId
        self.entityType = entityType
        self.name = name
        self.positions = positions
        self.normals = normals
        self.indices = indices
        self.color = color
        self.transform = transform
    }
}



extension MeshData: Equatable, Hashable {
    public static func ==(lhs: MeshData, rhs: MeshData) -> Bool {
        if lhs.entityId != rhs.entityId {
            return false
        }
        if lhs.entityType != rhs.entityType {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.positions != rhs.positions {
            return false
        }
        if lhs.normals != rhs.normals {
            return false
        }
        if lhs.indices != rhs.indices {
            return false
        }
        if lhs.color != rhs.color {
            return false
        }
        if lhs.transform != rhs.transform {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(entityId)
        hasher.combine(entityType)
        hasher.combine(name)
        hasher.combine(positions)
        hasher.combine(normals)
        hasher.combine(indices)
        hasher.combine(color)
        hasher.combine(transform)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMeshData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MeshData {
        return
            try MeshData(
                entityId: FfiConverterUInt64.read(from: &buf), 
                entityType: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                positions: FfiConverterSequenceFloat.read(from: &buf), 
                normals: FfiConverterSequenceFloat.read(from: &buf), 
                indices: FfiConverterSequenceUInt32.read(from: &buf), 
                color: FfiConverterSequenceFloat.read(from: &buf), 
                transform: FfiConverterSequenceFloat.read(from: &buf)
        )
    }

    public static func write(_ value: MeshData, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.entityId, into: &buf)
        FfiConverterString.write(value.entityType, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterSequenceFloat.write(value.positions, into: &buf)
        FfiConverterSequenceFloat.write(value.normals, into: &buf)
        FfiConverterSequenceUInt32.write(value.indices, into: &buf)
        FfiConverterSequenceFloat.write(value.color, into: &buf)
        FfiConverterSequenceFloat.write(value.transform, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMeshData_lift(_ buf: RustBuffer) throws -> MeshData {
    return try FfiConverterTypeMeshData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMeshData_lower(_ value: MeshData) -> RustBuffer {
    return FfiConverterTypeMeshData.lower(value)
}


/**
 * Property set
 */
public struct PropertySet {
    public var name: String
    public var properties: [PropertyValue]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, properties: [PropertyValue]) {
        self.name = name
        self.properties = properties
    }
}



extension PropertySet: Equatable, Hashable {
    public static func ==(lhs: PropertySet, rhs: PropertySet) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.properties != rhs.properties {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(properties)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePropertySet: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PropertySet {
        return
            try PropertySet(
                name: FfiConverterString.read(from: &buf), 
                properties: FfiConverterSequenceTypePropertyValue.read(from: &buf)
        )
    }

    public static func write(_ value: PropertySet, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterSequenceTypePropertyValue.write(value.properties, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePropertySet_lift(_ buf: RustBuffer) throws -> PropertySet {
    return try FfiConverterTypePropertySet.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePropertySet_lower(_ value: PropertySet) -> RustBuffer {
    return FfiConverterTypePropertySet.lower(value)
}


/**
 * Property value
 */
public struct PropertyValue {
    public var name: String
    public var value: String
    public var unit: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String, value: String, unit: String?) {
        self.name = name
        self.value = value
        self.unit = unit
    }
}



extension PropertyValue: Equatable, Hashable {
    public static func ==(lhs: PropertyValue, rhs: PropertyValue) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.unit != rhs.unit {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(unit)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePropertyValue: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PropertyValue {
        return
            try PropertyValue(
                name: FfiConverterString.read(from: &buf), 
                value: FfiConverterString.read(from: &buf), 
                unit: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: PropertyValue, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.value, into: &buf)
        FfiConverterOptionString.write(value.unit, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePropertyValue_lift(_ buf: RustBuffer) throws -> PropertyValue {
    return try FfiConverterTypePropertyValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePropertyValue_lower(_ value: PropertyValue) -> RustBuffer {
    return FfiConverterTypePropertyValue.lower(value)
}


/**
 * Scene bounds (AABB)
 */
public struct SceneBounds {
    public var minX: Float
    public var minY: Float
    public var minZ: Float
    public var maxX: Float
    public var maxY: Float
    public var maxZ: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minX: Float, minY: Float, minZ: Float, maxX: Float, maxY: Float, maxZ: Float) {
        self.minX = minX
        self.minY = minY
        self.minZ = minZ
        self.maxX = maxX
        self.maxY = maxY
        self.maxZ = maxZ
    }
}



extension SceneBounds: Equatable, Hashable {
    public static func ==(lhs: SceneBounds, rhs: SceneBounds) -> Bool {
        if lhs.minX != rhs.minX {
            return false
        }
        if lhs.minY != rhs.minY {
            return false
        }
        if lhs.minZ != rhs.minZ {
            return false
        }
        if lhs.maxX != rhs.maxX {
            return false
        }
        if lhs.maxY != rhs.maxY {
            return false
        }
        if lhs.maxZ != rhs.maxZ {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minX)
        hasher.combine(minY)
        hasher.combine(minZ)
        hasher.combine(maxX)
        hasher.combine(maxY)
        hasher.combine(maxZ)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSceneBounds: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SceneBounds {
        return
            try SceneBounds(
                minX: FfiConverterFloat.read(from: &buf), 
                minY: FfiConverterFloat.read(from: &buf), 
                minZ: FfiConverterFloat.read(from: &buf), 
                maxX: FfiConverterFloat.read(from: &buf), 
                maxY: FfiConverterFloat.read(from: &buf), 
                maxZ: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: SceneBounds, into buf: inout [UInt8]) {
        FfiConverterFloat.write(value.minX, into: &buf)
        FfiConverterFloat.write(value.minY, into: &buf)
        FfiConverterFloat.write(value.minZ, into: &buf)
        FfiConverterFloat.write(value.maxX, into: &buf)
        FfiConverterFloat.write(value.maxY, into: &buf)
        FfiConverterFloat.write(value.maxZ, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSceneBounds_lift(_ buf: RustBuffer) throws -> SceneBounds {
    return try FfiConverterTypeSceneBounds.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSceneBounds_lower(_ value: SceneBounds) -> RustBuffer {
    return FfiConverterTypeSceneBounds.lower(value)
}


/**
 * Section plane
 */
public struct SectionPlane {
    public var enabled: Bool
    public var originX: Float
    public var originY: Float
    public var originZ: Float
    public var normalX: Float
    public var normalY: Float
    public var normalZ: Float

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(enabled: Bool, originX: Float, originY: Float, originZ: Float, normalX: Float, normalY: Float, normalZ: Float) {
        self.enabled = enabled
        self.originX = originX
        self.originY = originY
        self.originZ = originZ
        self.normalX = normalX
        self.normalY = normalY
        self.normalZ = normalZ
    }
}



extension SectionPlane: Equatable, Hashable {
    public static func ==(lhs: SectionPlane, rhs: SectionPlane) -> Bool {
        if lhs.enabled != rhs.enabled {
            return false
        }
        if lhs.originX != rhs.originX {
            return false
        }
        if lhs.originY != rhs.originY {
            return false
        }
        if lhs.originZ != rhs.originZ {
            return false
        }
        if lhs.normalX != rhs.normalX {
            return false
        }
        if lhs.normalY != rhs.normalY {
            return false
        }
        if lhs.normalZ != rhs.normalZ {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(enabled)
        hasher.combine(originX)
        hasher.combine(originY)
        hasher.combine(originZ)
        hasher.combine(normalX)
        hasher.combine(normalY)
        hasher.combine(normalZ)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSectionPlane: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SectionPlane {
        return
            try SectionPlane(
                enabled: FfiConverterBool.read(from: &buf), 
                originX: FfiConverterFloat.read(from: &buf), 
                originY: FfiConverterFloat.read(from: &buf), 
                originZ: FfiConverterFloat.read(from: &buf), 
                normalX: FfiConverterFloat.read(from: &buf), 
                normalY: FfiConverterFloat.read(from: &buf), 
                normalZ: FfiConverterFloat.read(from: &buf)
        )
    }

    public static func write(_ value: SectionPlane, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterFloat.write(value.originX, into: &buf)
        FfiConverterFloat.write(value.originY, into: &buf)
        FfiConverterFloat.write(value.originZ, into: &buf)
        FfiConverterFloat.write(value.normalX, into: &buf)
        FfiConverterFloat.write(value.normalY, into: &buf)
        FfiConverterFloat.write(value.normalZ, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSectionPlane_lift(_ buf: RustBuffer) throws -> SectionPlane {
    return try FfiConverterTypeSectionPlane.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSectionPlane_lower(_ value: SectionPlane) -> RustBuffer {
    return FfiConverterTypeSectionPlane.lower(value)
}


/**
 * Selection state
 */
public struct SelectionState {
    public var selectedIds: [UInt64]
    public var hoveredId: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(selectedIds: [UInt64], hoveredId: UInt64?) {
        self.selectedIds = selectedIds
        self.hoveredId = hoveredId
    }
}



extension SelectionState: Equatable, Hashable {
    public static func ==(lhs: SelectionState, rhs: SelectionState) -> Bool {
        if lhs.selectedIds != rhs.selectedIds {
            return false
        }
        if lhs.hoveredId != rhs.hoveredId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(selectedIds)
        hasher.combine(hoveredId)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSelectionState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SelectionState {
        return
            try SelectionState(
                selectedIds: FfiConverterSequenceUInt64.read(from: &buf), 
                hoveredId: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: SelectionState, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.selectedIds, into: &buf)
        FfiConverterOptionUInt64.write(value.hoveredId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionState_lift(_ buf: RustBuffer) throws -> SelectionState {
    return try FfiConverterTypeSelectionState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSelectionState_lower(_ value: SelectionState) -> RustBuffer {
    return FfiConverterTypeSelectionState.lower(value)
}


/**
 * Spatial hierarchy node
 */
public struct SpatialNode {
    public var id: UInt64
    public var nodeType: String
    public var name: String
    public var entityType: String
    public var elevation: Float?
    public var hasGeometry: Bool
    public var children: [SpatialNode]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: UInt64, nodeType: String, name: String, entityType: String, elevation: Float?, hasGeometry: Bool, children: [SpatialNode]) {
        self.id = id
        self.nodeType = nodeType
        self.name = name
        self.entityType = entityType
        self.elevation = elevation
        self.hasGeometry = hasGeometry
        self.children = children
    }
}



extension SpatialNode: Equatable, Hashable {
    public static func ==(lhs: SpatialNode, rhs: SpatialNode) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.nodeType != rhs.nodeType {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.entityType != rhs.entityType {
            return false
        }
        if lhs.elevation != rhs.elevation {
            return false
        }
        if lhs.hasGeometry != rhs.hasGeometry {
            return false
        }
        if lhs.children != rhs.children {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(nodeType)
        hasher.combine(name)
        hasher.combine(entityType)
        hasher.combine(elevation)
        hasher.combine(hasGeometry)
        hasher.combine(children)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpatialNode: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpatialNode {
        return
            try SpatialNode(
                id: FfiConverterUInt64.read(from: &buf), 
                nodeType: FfiConverterString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                entityType: FfiConverterString.read(from: &buf), 
                elevation: FfiConverterOptionFloat.read(from: &buf), 
                hasGeometry: FfiConverterBool.read(from: &buf), 
                children: FfiConverterSequenceTypeSpatialNode.read(from: &buf)
        )
    }

    public static func write(_ value: SpatialNode, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.id, into: &buf)
        FfiConverterString.write(value.nodeType, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.entityType, into: &buf)
        FfiConverterOptionFloat.write(value.elevation, into: &buf)
        FfiConverterBool.write(value.hasGeometry, into: &buf)
        FfiConverterSequenceTypeSpatialNode.write(value.children, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpatialNode_lift(_ buf: RustBuffer) throws -> SpatialNode {
    return try FfiConverterTypeSpatialNode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpatialNode_lower(_ value: SpatialNode) -> RustBuffer {
    return FfiConverterTypeSpatialNode.lower(value)
}


/**
 * Visibility state
 */
public struct VisibilityState {
    public var hiddenIds: [UInt64]
    public var isolatedIds: [UInt64]?
    public var storeyFilter: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(hiddenIds: [UInt64], isolatedIds: [UInt64]?, storeyFilter: String?) {
        self.hiddenIds = hiddenIds
        self.isolatedIds = isolatedIds
        self.storeyFilter = storeyFilter
    }
}



extension VisibilityState: Equatable, Hashable {
    public static func ==(lhs: VisibilityState, rhs: VisibilityState) -> Bool {
        if lhs.hiddenIds != rhs.hiddenIds {
            return false
        }
        if lhs.isolatedIds != rhs.isolatedIds {
            return false
        }
        if lhs.storeyFilter != rhs.storeyFilter {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(hiddenIds)
        hasher.combine(isolatedIds)
        hasher.combine(storeyFilter)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVisibilityState: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VisibilityState {
        return
            try VisibilityState(
                hiddenIds: FfiConverterSequenceUInt64.read(from: &buf), 
                isolatedIds: FfiConverterOptionSequenceUInt64.read(from: &buf), 
                storeyFilter: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VisibilityState, into buf: inout [UInt8]) {
        FfiConverterSequenceUInt64.write(value.hiddenIds, into: &buf)
        FfiConverterOptionSequenceUInt64.write(value.isolatedIds, into: &buf)
        FfiConverterOptionString.write(value.storeyFilter, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVisibilityState_lift(_ buf: RustBuffer) throws -> VisibilityState {
    return try FfiConverterTypeVisibilityState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVisibilityState_lower(_ value: VisibilityState) -> RustBuffer {
    return FfiConverterTypeVisibilityState.lower(value)
}


/**
 * Error type for FFI operations
 */
public enum IfcError {

    
    
    case ParseError(msg: String
    )
    case GeometryError(msg: String
    )
    case IoError(msg: String
    )
    case InvalidHandle
    case NotLoaded
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIfcError: FfiConverterRustBuffer {
    typealias SwiftType = IfcError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IfcError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .ParseError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .GeometryError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .IoError(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 4: return .InvalidHandle
        case 5: return .NotLoaded

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: IfcError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .ParseError(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .GeometryError(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .IoError(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        
        case .InvalidHandle:
            writeInt(&buf, Int32(4))
        
        
        case .NotLoaded:
            writeInt(&buf, Int32(5))
        
        }
    }
}


extension IfcError: Equatable, Hashable {}

extension IfcError: Foundation.LocalizedError {
    public var errorDescription: String? {
        String(reflecting: self)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionFloat: FfiConverterRustBuffer {
    typealias SwiftType = Float?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterFloat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterFloat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEntityInfo: FfiConverterRustBuffer {
    typealias SwiftType = EntityInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEntityInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEntityInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMeshData: FfiConverterRustBuffer {
    typealias SwiftType = MeshData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMeshData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMeshData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSceneBounds: FfiConverterRustBuffer {
    typealias SwiftType = SceneBounds?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSceneBounds.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSceneBounds.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSpatialNode: FfiConverterRustBuffer {
    typealias SwiftType = SpatialNode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSpatialNode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSpatialNode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt32: FfiConverterRustBuffer {
    typealias SwiftType = [UInt32]

    public static func write(_ value: [UInt32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt32.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt32] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt32]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt32.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt64: FfiConverterRustBuffer {
    typealias SwiftType = [UInt64]

    public static func write(_ value: [UInt64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt64.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt64] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt64]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt64.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceFloat: FfiConverterRustBuffer {
    typealias SwiftType = [Float]

    public static func write(_ value: [Float], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterFloat.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Float] {
        let len: Int32 = try readInt(&buf)
        var seq = [Float]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterFloat.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeEntityInfo: FfiConverterRustBuffer {
    typealias SwiftType = [EntityInfo]

    public static func write(_ value: [EntityInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeEntityInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [EntityInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [EntityInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeEntityInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMeshData: FfiConverterRustBuffer {
    typealias SwiftType = [MeshData]

    public static func write(_ value: [MeshData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMeshData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [MeshData] {
        let len: Int32 = try readInt(&buf)
        var seq = [MeshData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMeshData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePropertySet: FfiConverterRustBuffer {
    typealias SwiftType = [PropertySet]

    public static func write(_ value: [PropertySet], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePropertySet.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PropertySet] {
        let len: Int32 = try readInt(&buf)
        var seq = [PropertySet]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePropertySet.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePropertyValue: FfiConverterRustBuffer {
    typealias SwiftType = [PropertyValue]

    public static func write(_ value: [PropertyValue], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePropertyValue.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PropertyValue] {
        let len: Int32 = try readInt(&buf)
        var seq = [PropertyValue]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePropertyValue.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSpatialNode: FfiConverterRustBuffer {
    typealias SwiftType = [SpatialNode]

    public static func write(_ value: [SpatialNode], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSpatialNode.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SpatialNode] {
        let len: Int32 = try readInt(&buf)
        var seq = [SpatialNode]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSpatialNode.read(from: &buf))
        }
        return seq
    }
}
/**
 * Get library version
 */
public func getVersion() -> String {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_ifc_lite_ffi_fn_func_get_version($0
    )
})
}
/**
 * Initialize the library (call once at app startup)
 */
public func initLibrary() {try! rustCall() {
    uniffi_ifc_lite_ffi_fn_func_init_library($0
    )
}
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_ifc_lite_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_func_get_version() != 39133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_func_init_library() != 5655) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_add_to_selection() != 37207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_clear() != 9164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_clear_selection() != 14958) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_bounds() != 58716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_camera_state() != 7551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_entities() != 21942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_entity() != 32666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_mesh() != 42338) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_meshes() != 20456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_properties() != 57446) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_section_plane() != 42041) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_selection() != 28716) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_spatial_tree() != 10033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_visibility() != 53804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_get_visible_count() != 51846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_hide_entity() != 61989) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_is_entity_visible() != 16848) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_is_loaded() != 38939) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_isolate_entities() != 65147) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_isolate_entity() != 45705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_load_bytes() != 32697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_load_file() != 10880) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_load_string() != 30274) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_remove_from_selection() != 50352) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_select() != 12021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_set_camera_state() != 8662) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_set_section_plane() != 22119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_set_storey_filter() != 3690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_show_all() != 36033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_show_entity() != 11734) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_method_ifcscene_toggle_selection() != 40545) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_ifc_lite_ffi_checksum_constructor_ifcscene_new() != 46456) {
        return InitializationResult.apiChecksumMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all